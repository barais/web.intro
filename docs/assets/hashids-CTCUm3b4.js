const E=n=>[...new Set(n)],v=(n,t)=>n.filter(e=>!t.includes(e)),N=(n,t)=>n.filter(e=>t.includes(e)),B=n=>typeof n=="bigint"||!Number.isNaN(Number(n))&&Math.floor(Number(n))===n,$=n=>typeof n=="bigint"||n>=0&&Number.isSafeInteger(n);function f(n,t){if(t.length===0)return n;let e;const i=[...n];for(let s=i.length-1,o=0,g=0;s>0;s--,o++){o%=t.length,g+=e=t[o].codePointAt(0);const a=(e+o+g)%s,l=i[s],r=i[a];i[a]=l,i[s]=r}return i}const R=(n,t)=>{const e=[];let i=n;if(typeof i=="bigint"){const s=BigInt(t.length);do e.unshift(t[Number(i%s)]),i/=s;while(i>BigInt(0))}else do e.unshift(t[i%t.length]),i=Math.floor(i/t.length);while(i>0);return e},T=(n,t)=>n.reduce((e,i)=>{const s=t.indexOf(i);if(s===-1)throw new Error(`The provided ID (${n.join("")}) is invalid, as it contains characters that do not exist in the alphabet (${t.join("")})`);if(typeof e=="bigint")return e*BigInt(t.length)+BigInt(s);const o=e*t.length+s;return Number.isSafeInteger(o)?o:(w("Unable to decode the provided string, due to lack of support for BigInt numbers in the current environment"),BigInt(e)*BigInt(t.length)+BigInt(s))},0),S=/^\+?\d+$/,H=n=>{if(!S.test(n))return Number.NaN;const t=Number.parseInt(n,10);return Number.isSafeInteger(t)?t:(w("Unable to encode the provided BigInt string without loss of information due to lack of support for BigInt type in the current environment"),BigInt(n))},L=(n,t,e)=>Array.from({length:Math.ceil(n.length/t)},(i,s)=>e(n.slice(s*t,(s+1)*t))),d=n=>new RegExp(n.map(t=>A(t)).sort((t,e)=>e.length-t.length).join("|")),P=n=>new RegExp(`^[${n.map(t=>A(t)).sort((t,e)=>e.length-t.length).join("")}]+$`),A=n=>n.replace(/[\s#$()*+,.?[\\\]^{|}-]/g,"\\$&"),w=(n="BigInt is not available in this environment")=>{if(typeof BigInt!="function")throw new TypeError(n)},b=16,I=3.5,_=12,m=16,j=12,y=100;class M{constructor(t="",e=0,i="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",s="cfhistuCFHISTU"){if(this.minLength=e,typeof e!="number")throw new TypeError(`Hashids: Provided 'minLength' has to be a number (is ${typeof e})`);if(typeof t!="string")throw new TypeError(`Hashids: Provided 'salt' has to be a string (is ${typeof t})`);if(typeof i!="string")throw new TypeError(`Hashids: Provided alphabet has to be a string (is ${typeof i})`);const o=Array.from(t),g=Array.from(i),a=Array.from(s);this.salt=o;const l=E(g);if(l.length<b)throw new Error(`Hashids: alphabet must contain at least ${b} unique characters, provided: ${l.join("")}`);this.alphabet=v(l,a);const r=N(a,l);this.seps=f(r,o);let h,c;(this.seps.length===0||this.alphabet.length/this.seps.length>I)&&(h=Math.ceil(this.alphabet.length/I),h>this.seps.length&&(c=h-this.seps.length,this.seps.push(...this.alphabet.slice(0,c)),this.alphabet=this.alphabet.slice(c))),this.alphabet=f(this.alphabet,o);const p=Math.ceil(this.alphabet.length/_);this.alphabet.length<3?(this.guards=this.seps.slice(0,p),this.seps=this.seps.slice(p)):(this.guards=this.alphabet.slice(0,p),this.alphabet=this.alphabet.slice(p)),this.guardsRegExp=d(this.guards),this.sepsRegExp=d(this.seps),this.allowedCharsRegExp=P([...this.alphabet,...this.guards,...this.seps])}encode(t,...e){const i="";let s=Array.isArray(t)?t:[...t!=null?[t]:[],...e];return s.length===0||(s.every(B)||(s=s.map(o=>typeof o=="bigint"||typeof o=="number"?o:H(String(o)))),!s.every($))?i:this._encode(s).join("")}decode(t){return!t||typeof t!="string"||t.length===0?[]:this._decode(t)}encodeHex(t){let e=t;switch(typeof e){case"bigint":e=e.toString(m);break;case"string":if(!/^[\dA-Fa-f]+$/.test(e))return"";break;default:throw new Error(`Hashids: The provided value is neither a string, nor a BigInt (got: ${typeof e})`)}const i=L(e,j,s=>Number.parseInt(`1${s}`,16));return this.encode(i)}decodeHex(t){return this.decode(t).map(e=>e.toString(m).slice(1)).join("")}isValidId(t){return this.allowedCharsRegExp.test(t)}_encode(t){let{alphabet:e}=this;const i=t.reduce((r,h,c)=>r+(typeof h=="bigint"?Number(h%BigInt(c+y)):h%(c+y)),0);let s=[e[i%e.length]];const o=[...s],{seps:g}=this,{guards:a}=this;if(t.forEach((r,h)=>{const c=o.concat(this.salt,e);e=f(e,c);const p=R(r,e);if(s.push(...p),h+1<t.length){const u=p[0].codePointAt(0)+h,x=typeof r=="bigint"?Number(r%BigInt(u)):r%u;s.push(g[x%g.length])}}),s.length<this.minLength){const r=(i+s[0].codePointAt(0))%a.length;if(s.unshift(a[r]),s.length<this.minLength){const h=(i+s[2].codePointAt(0))%a.length;s.push(a[h])}}const l=Math.floor(e.length/2);for(;s.length<this.minLength;){e=f(e,e),s.unshift(...e.slice(l)),s.push(...e.slice(0,l));const r=s.length-this.minLength;if(r>0){const h=r/2;s=s.slice(h,h+this.minLength)}}return s}_decode(t){if(!this.isValidId(t))throw new Error(`The provided ID (${t}) is invalid, as it contains characters that do not exist in the alphabet (${this.guards.join("")}${this.seps.join("")}${this.alphabet.join("")})`);const e=t.split(this.guardsRegExp),i=e.length===3||e.length===2?1:0,s=e[i];if(s.length===0)return[];const o=s[Symbol.iterator]().next().value,g=s.slice(o.length).split(this.sepsRegExp);let a=this.alphabet;const l=[];for(const r of g){const h=[o,...this.salt,...a],c=f(a,h.slice(0,a.length));l.push(T(Array.from(r),c)),a=c}return this._encode(l).join("")!==t?[]:l}}export{M as H};
